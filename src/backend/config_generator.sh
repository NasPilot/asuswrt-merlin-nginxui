#!/bin/sh

# NGINXUI Configuration Generator Script

# Source global variables
. "$(dirname "$0")/_globals.sh"

# Configuration generation functions
generate_nginx_config() {
    local mode="$1"
    local config_data="$2"
    
    log_info "Generating Nginx configuration in $mode mode"
    
    # Backup existing configuration
    backup_nginx_config
    
    case "$mode" in
        "basic")
            generate_basic_config "$config_data"
            ;;
        "advanced")
            generate_advanced_config "$config_data"
            ;;
        *)
            log_error "Unknown configuration mode: $mode"
            return 1
            ;;
    esac
    
    # Validate generated configuration
    if test_nginx_config; then
        log_info "Nginx configuration generated successfully"
        return 0
    else
        log_error "Generated configuration is invalid, restoring backup"
        restore_nginx_config
        return 1
    fi
}

generate_basic_config() {
    local config_data="$1"
    
    log_info "Generating basic Nginx configuration"
    
    # Parse basic configuration parameters
    local nginx_enabled=$(echo "$config_data" | jq -r '.nginx_enabled // "1"')
    local listen_port=$(echo "$config_data" | jq -r '.listen_port // "80"')
    local ssl_port=$(echo "$config_data" | jq -r '.ssl_port // "443"')
    local server_name=$(echo "$config_data" | jq -r '.server_name // "_"')
    local document_root=$(echo "$config_data" | jq -r '.document_root // "/opt/share/www"')
    local index_files=$(echo "$config_data" | jq -r '.index_files // "index.html index.htm"')
    local ssl_enabled=$(echo "$config_data" | jq -r '.ssl_enabled // "0"')
    local ssl_cert=$(echo "$config_data" | jq -r '.ssl_cert // ""')
    local ssl_key=$(echo "$config_data" | jq -r '.ssl_key // ""')
    local access_log=$(echo "$config_data" | jq -r '.access_log // "on"')
    local error_log=$(echo "$config_data" | jq -r '.error_log // "on"')
    
    # Validate parameters
    if ! validate_port "$listen_port"; then
        log_error "Invalid listen port: $listen_port"
        return 1
    fi
    
    if [ "$ssl_enabled" = "1" ] && ! validate_port "$ssl_port"; then
        log_error "Invalid SSL port: $ssl_port"
        return 1
    fi
    
    if ! validate_domain "$server_name" && [ "$server_name" != "_" ]; then
        log_error "Invalid server name: $server_name"
        return 1
    fi
    
    # Generate main nginx.conf
    cat > "$NGINX_CONF" << EOF
# Nginx configuration generated by NGINXUI
# Mode: Basic
# Generated: $(date)

user nobody;
worker_processes $DEFAULT_WORKER_PROCESSES;
error_log $NGINX_ERROR_LOG;
pid $NGINX_PID;

events {
    worker_connections $DEFAULT_WORKER_CONNECTIONS;
}

http {
    # MIME types
    include /opt/etc/nginx/mime.types;
    default_type application/octet-stream;

    # Logging format
    log_format main '\$remote_addr - \$remote_user [\$time_local] "\$request" '
                    '\$status \$body_bytes_sent "\$http_referer" '
                    '"\$http_user_agent" "\$http_x_forwarded_for"';

    # Basic settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout $DEFAULT_KEEPALIVE_TIMEOUT;
    client_max_body_size $DEFAULT_CLIENT_MAX_BODY_SIZE;
    types_hash_max_size 2048;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;

    # Main server block
    server {
EOF

    # Add listen directives
    echo "        listen $listen_port;" >> "$NGINX_CONF"
    echo "        listen [::]:$listen_port;" >> "$NGINX_CONF"
    
    # Add SSL listen directives if enabled
    if [ "$ssl_enabled" = "1" ]; then
        echo "        listen $ssl_port ssl;" >> "$NGINX_CONF"
        echo "        listen [::]:$ssl_port ssl;" >> "$NGINX_CONF"
    fi
    
    # Continue with server configuration
    cat >> "$NGINX_CONF" << EOF
        server_name $server_name;
        root $document_root;
        index $index_files;

EOF

    # Add SSL configuration if enabled
    if [ "$ssl_enabled" = "1" ] && [ -n "$ssl_cert" ] && [ -n "$ssl_key" ]; then
        cat >> "$NGINX_CONF" << EOF
        # SSL configuration
        ssl_certificate $ssl_cert;
        ssl_certificate_key $ssl_key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers $DEFAULT_SSL_CIPHERS;
        ssl_prefer_server_ciphers on;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;

EOF
    fi
    
    # Add logging configuration
    if [ "$access_log" = "on" ]; then
        echo "        access_log $NGINX_ACCESS_LOG main;" >> "$NGINX_CONF"
    else
        echo "        access_log off;" >> "$NGINX_CONF"
    fi
    
    if [ "$error_log" = "on" ]; then
        echo "        error_log $NGINX_ERROR_LOG;" >> "$NGINX_CONF"
    fi
    
    # Add location blocks
    cat >> "$NGINX_CONF" << 'EOF'

        # Main location
        location / {
            try_files $uri $uri/ =404;
        }

        # Nginx status page
        location /nginx_status {
            stub_status on;
            access_log off;
            allow 127.0.0.1;
            allow 192.168.0.0/16;
            allow 10.0.0.0/8;
            allow 172.16.0.0/12;
            deny all;
        }

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header Referrer-Policy "no-referrer-when-downgrade" always;
        add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
    }

    # Include additional configurations
    include /opt/etc/nginx/conf.d/*.conf;
}
EOF

    # Ensure document root exists
    ensure_dir "$document_root"
    
    # Create default index.html if it doesn't exist
    if [ ! -f "$document_root/index.html" ]; then
        create_default_index "$document_root"
    fi
    
    log_info "Basic Nginx configuration generated"
    return 0
}

generate_advanced_config() {
    local config_data="$1"
    
    log_info "Generating advanced Nginx configuration"
    
    # Parse advanced configuration parameters
    local worker_processes=$(echo "$config_data" | jq -r '.worker_processes // "auto"')
    local worker_connections=$(echo "$config_data" | jq -r '.worker_connections // "1024"')
    local keepalive_timeout=$(echo "$config_data" | jq -r '.keepalive_timeout // "65"')
    local client_max_body_size=$(echo "$config_data" | jq -r '.client_max_body_size // "1m"')
    local gzip_enabled=$(echo "$config_data" | jq -r '.gzip_enabled // "1"')
    local custom_directives=$(echo "$config_data" | jq -r '.custom_directives // ""')
    
    # Generate main nginx.conf
    cat > "$NGINX_CONF" << EOF
# Nginx configuration generated by NGINXUI
# Mode: Advanced
# Generated: $(date)

user nobody;
worker_processes $worker_processes;
error_log $NGINX_ERROR_LOG;
pid $NGINX_PID;

events {
    worker_connections $worker_connections;
    use epoll;
    multi_accept on;
}

http {
    # MIME types
    include /opt/etc/nginx/mime.types;
    default_type application/octet-stream;

    # Logging format
    log_format main '\$remote_addr - \$remote_user [\$time_local] "\$request" '
                    '\$status \$body_bytes_sent "\$http_referer" '
                    '"\$http_user_agent" "\$http_x_forwarded_for"';

    log_format detailed '\$remote_addr - \$remote_user [\$time_local] "\$request" '
                       '\$status \$body_bytes_sent "\$http_referer" '
                       '"\$http_user_agent" "\$http_x_forwarded_for" '
                       'rt=\$request_time uct="\$upstream_connect_time" '
                       'uht="\$upstream_header_time" urt="\$upstream_response_time"';

    # Basic settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout $keepalive_timeout;
    client_max_body_size $client_max_body_size;
    types_hash_max_size 2048;
    server_tokens off;

    # Buffer settings
    client_body_buffer_size 128k;
    client_header_buffer_size 1k;
    large_client_header_buffers 4 4k;
    output_buffers 1 32k;
    postpone_output 1460;

EOF

    # Add gzip configuration if enabled
    if [ "$gzip_enabled" = "1" ]; then
        cat >> "$NGINX_CONF" << 'EOF'
    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_min_length 1000;
    gzip_disable "msie6";
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml
        application/x-font-ttf
        application/vnd.ms-fontobject
        font/opentype;

EOF
    fi
    
    # Add custom directives if provided
    if [ -n "$custom_directives" ]; then
        echo "    # Custom directives" >> "$NGINX_CONF"
        echo "$custom_directives" | sed 's/^/    /' >> "$NGINX_CONF"
        echo "" >> "$NGINX_CONF"
    fi
    
    # Add rate limiting
    cat >> "$NGINX_CONF" << 'EOF'
    # Rate limiting
    limit_req_zone $binary_remote_addr zone=login:10m rate=10r/m;
    limit_req_zone $binary_remote_addr zone=api:10m rate=1r/s;

    # Include upstream configurations
    include /opt/etc/nginx/conf.d/upstream.conf;

    # Include server configurations
    include /opt/etc/nginx/conf.d/*.conf;
    include /opt/etc/nginx/sites-enabled/*;
}
EOF

    # Generate server blocks from configuration data
    local servers=$(echo "$config_data" | jq -r '.servers // []')
    if [ "$servers" != "[]" ] && [ "$servers" != "null" ]; then
        generate_server_blocks "$servers"
    fi
    
    # Generate upstream configurations
    local upstreams=$(echo "$config_data" | jq -r '.upstreams // []')
    if [ "$upstreams" != "[]" ] && [ "$upstreams" != "null" ]; then
        generate_upstream_config "$upstreams"
    fi
    
    log_info "Advanced Nginx configuration generated"
    return 0
}

generate_server_blocks() {
    local servers_json="$1"
    local server_count=0
    
    log_info "Generating server blocks"
    
    # Ensure conf.d directory exists
    ensure_dir "$NGINX_CONF_DIR/conf.d"
    
    # Parse each server configuration
    echo "$servers_json" | jq -c '.[]' | while read -r server; do
        server_count=$((server_count + 1))
        
        local listen_port=$(echo "$server" | jq -r '.listen_port // "80"')
        local server_name=$(echo "$server" | jq -r '.server_name // "_"')
        local document_root=$(echo "$server" | jq -r '.document_root // "/opt/share/www"')
        local index_files=$(echo "$server" | jq -r '.index_files // "index.html index.htm"')
        local ssl_enabled=$(echo "$server" | jq -r '.ssl_enabled // "0"')
        local ssl_cert=$(echo "$server" | jq -r '.ssl_cert // ""')
        local ssl_key=$(echo "$server" | jq -r '.ssl_key // ""')
        local custom_config=$(echo "$server" | jq -r '.custom_config // ""')
        
        # Generate server configuration file
        local server_file="$NGINX_CONF_DIR/conf.d/server_${server_count}.conf"
        
        cat > "$server_file" << EOF
# Server block $server_count
server {
    listen $listen_port;
    listen [::]:$listen_port;
EOF

        # Add SSL configuration if enabled
        if [ "$ssl_enabled" = "1" ]; then
            local ssl_port=$(echo "$server" | jq -r '.ssl_port // "443"')
            cat >> "$server_file" << EOF
    listen $ssl_port ssl;
    listen [::]:$ssl_port ssl;
    
    ssl_certificate $ssl_cert;
    ssl_certificate_key $ssl_key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers $DEFAULT_SSL_CIPHERS;
    ssl_prefer_server_ciphers on;
EOF
        fi
        
        cat >> "$server_file" << EOF
    
    server_name $server_name;
    root $document_root;
    index $index_files;
    
    access_log $NGINX_ACCESS_LOG main;
    error_log $NGINX_ERROR_LOG;
    
    location / {
        try_files \$uri \$uri/ =404;
    }
EOF

        # Add custom configuration if provided
        if [ -n "$custom_config" ]; then
            echo "    " >> "$server_file"
            echo "    # Custom configuration" >> "$server_file"
            echo "$custom_config" | sed 's/^/    /' >> "$server_file"
        fi
        
        echo "}" >> "$server_file"
        
        # Ensure document root exists
        ensure_dir "$document_root"
        
        log_info "Generated server block $server_count: $server_name:$listen_port"
    done
    
    return 0
}

generate_upstream_config() {
    local upstreams_json="$1"
    
    log_info "Generating upstream configurations"
    
    # Ensure conf.d directory exists
    ensure_dir "$NGINX_CONF_DIR/conf.d"
    
    # Generate upstream configuration file
    local upstream_file="$NGINX_CONF_DIR/conf.d/upstream.conf"
    
    cat > "$upstream_file" << 'EOF'
# Upstream configurations generated by NGINXUI

EOF

    # Parse each upstream configuration
    echo "$upstreams_json" | jq -c '.[]' | while read -r upstream; do
        local name=$(echo "$upstream" | jq -r '.name')
        local method=$(echo "$upstream" | jq -r '.method // "round_robin"')
        local servers=$(echo "$upstream" | jq -r '.servers // []')
        local health_check=$(echo "$upstream" | jq -r '.health_check // "0"')
        local custom_config=$(echo "$upstream" | jq -r '.custom_config // ""')
        
        cat >> "$upstream_file" << EOF
upstream $name {
EOF

        # Add load balancing method
        case "$method" in
            "least_conn")
                echo "    least_conn;" >> "$upstream_file"
                ;;
            "ip_hash")
                echo "    ip_hash;" >> "$upstream_file"
                ;;
            "hash")
                local hash_key=$(echo "$upstream" | jq -r '.hash_key // "$remote_addr"')
                echo "    hash $hash_key;" >> "$upstream_file"
                ;;
        esac
        
        # Add servers
        echo "$servers" | jq -c '.[]' | while read -r server; do
            local address=$(echo "$server" | jq -r '.address')
            local weight=$(echo "$server" | jq -r '.weight // "1"')
            local max_fails=$(echo "$server" | jq -r '.max_fails // "1"')
            local fail_timeout=$(echo "$server" | jq -r '.fail_timeout // "10s"')
            local backup=$(echo "$server" | jq -r '.backup // "0"')
            local down=$(echo "$server" | jq -r '.down // "0"')
            
            local server_line="    server $address weight=$weight max_fails=$max_fails fail_timeout=$fail_timeout"
            
            if [ "$backup" = "1" ]; then
                server_line="$server_line backup"
            fi
            
            if [ "$down" = "1" ]; then
                server_line="$server_line down"
            fi
            
            echo "$server_line;" >> "$upstream_file"
        done
        
        # Add health check if enabled
        if [ "$health_check" = "1" ]; then
            local check_uri=$(echo "$upstream" | jq -r '.check_uri // "/"')
            local check_interval=$(echo "$upstream" | jq -r '.check_interval // "30s"')
            echo "    # Health check: $check_uri every $check_interval" >> "$upstream_file"
        fi
        
        # Add custom configuration if provided
        if [ -n "$custom_config" ]; then
            echo "    " >> "$upstream_file"
            echo "    # Custom configuration" >> "$upstream_file"
            echo "$custom_config" | sed 's/^/    /' >> "$upstream_file"
        fi
        
        echo "}" >> "$upstream_file"
        echo "" >> "$upstream_file"
        
        log_info "Generated upstream: $name"
    done
    
    return 0
}

generate_ssl_config() {
    local ssl_data="$1"
    
    log_info "Generating SSL configuration"
    
    local ssl_enabled=$(echo "$ssl_data" | jq -r '.ssl_enabled // "0"')
    
    if [ "$ssl_enabled" != "1" ]; then
        log_info "SSL is disabled, skipping SSL configuration"
        return 0
    fi
    
    # Parse SSL configuration
    local ssl_protocols=$(echo "$ssl_data" | jq -r '.ssl_protocols // "TLSv1.2 TLSv1.3"')
    local ssl_ciphers=$(echo "$ssl_data" | jq -r '.ssl_ciphers // ""')
    local ssl_cert=$(echo "$ssl_data" | jq -r '.ssl_cert // ""')
    local ssl_key=$(echo "$ssl_data" | jq -r '.ssl_key // ""')
    local ssl_dhparam=$(echo "$ssl_data" | jq -r '.ssl_dhparam // ""')
    local ssl_session_cache=$(echo "$ssl_data" | jq -r '.ssl_session_cache // "shared:SSL:10m"')
    local ssl_session_timeout=$(echo "$ssl_data" | jq -r '.ssl_session_timeout // "10m"')
    local ssl_stapling=$(echo "$ssl_data" | jq -r '.ssl_stapling // "0"')
    local hsts_enabled=$(echo "$ssl_data" | jq -r '.hsts_enabled // "0"')
    local hsts_max_age=$(echo "$ssl_data" | jq -r '.hsts_max_age // "31536000"')
    local redirect_http=$(echo "$ssl_data" | jq -r '.redirect_http // "0"')
    
    # Use default ciphers if not specified
    if [ -z "$ssl_ciphers" ]; then
        ssl_ciphers="$DEFAULT_SSL_CIPHERS"
    fi
    
    # Generate SSL configuration file
    local ssl_file="$NGINX_CONF_DIR/conf.d/ssl.conf"
    
    cat > "$ssl_file" << EOF
# SSL configuration generated by NGINXUI

# SSL protocols and ciphers
ssl_protocols $ssl_protocols;
ssl_ciphers $ssl_ciphers;
ssl_prefer_server_ciphers on;

# SSL session settings
ssl_session_cache $ssl_session_cache;
ssl_session_timeout $ssl_session_timeout;
ssl_session_tickets off;

EOF

    # Add DH parameters if specified
    if [ -n "$ssl_dhparam" ] && [ -f "$ssl_dhparam" ]; then
        echo "ssl_dhparam $ssl_dhparam;" >> "$ssl_file"
        echo "" >> "$ssl_file"
    fi
    
    # Add OCSP stapling if enabled
    if [ "$ssl_stapling" = "1" ]; then
        cat >> "$ssl_file" << 'EOF'
# OCSP stapling
ssl_stapling on;
ssl_stapling_verify on;
resolver 8.8.8.8 8.8.4.4 valid=300s;
resolver_timeout 5s;

EOF
    fi
    
    # Add HSTS if enabled
    if [ "$hsts_enabled" = "1" ]; then
        echo "# HTTP Strict Transport Security" >> "$ssl_file"
        echo "add_header Strict-Transport-Security \"max-age=$hsts_max_age; includeSubDomains\" always;" >> "$ssl_file"
        echo "" >> "$ssl_file"
    fi
    
    # Add HTTP to HTTPS redirect if enabled
    if [ "$redirect_http" = "1" ]; then
        cat >> "$ssl_file" << 'EOF'
# HTTP to HTTPS redirect
server {
    listen 80;
    listen [::]:80;
    server_name _;
    return 301 https://$server_name$request_uri;
}

EOF
    fi
    
    log_info "SSL configuration generated"
    return 0
}

# Backup and restore functions
backup_nginx_config() {
    if [ -f "$NGINX_CONF" ]; then
        local backup_file="$NGINXUI_BACKUP_DIR/nginx.conf.backup.$(date +%Y%m%d_%H%M%S)"
        cp "$NGINX_CONF" "$backup_file"
        log_info "Nginx configuration backed up to $backup_file"
    fi
    
    # Backup conf.d directory
    if [ -d "$NGINX_CONF_DIR/conf.d" ]; then
        local backup_dir="$NGINXUI_BACKUP_DIR/conf.d.backup.$(date +%Y%m%d_%H%M%S)"
        cp -r "$NGINX_CONF_DIR/conf.d" "$backup_dir"
        log_info "Nginx conf.d directory backed up to $backup_dir"
    fi
    
    return 0
}

restore_nginx_config() {
    local backup_file=$(ls -t "$NGINXUI_BACKUP_DIR"/nginx.conf.backup.* 2>/dev/null | head -n1)
    
    if [ -n "$backup_file" ] && [ -f "$backup_file" ]; then
        cp "$backup_file" "$NGINX_CONF"
        log_info "Nginx configuration restored from $backup_file"
        return 0
    else
        log_error "No backup file found to restore"
        return 1
    fi
}

# Utility functions
create_default_index() {
    local document_root="$1"
    
    cat > "$document_root/index.html" << 'EOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to Nginx</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 40px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .container {
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
            max-width: 600px;
        }
        h1 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 2.5em;
        }
        p {
            margin-bottom: 15px;
            font-size: 1.1em;
            color: #555;
        }
        .logo {
            font-size: 4em;
            margin-bottom: 20px;
            color: #27ae60;
        }
        .info {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin-top: 20px;
            border-left: 4px solid #27ae60;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="logo">ðŸš€</div>
        <h1>Welcome to Nginx!</h1>
        <p>Congratulations! Nginx is successfully installed and running on your ASUSWRT-Merlin router.</p>
        <p>This page is served by <strong>NGINXUI</strong>, a web-based management interface for Nginx.</p>
        
        <div class="info">
            <p><strong>What's next?</strong></p>
            <p>â€¢ Configure your server blocks and upstreams through the NGINXUI interface</p>
            <p>â€¢ Upload your website files to the document root</p>
            <p>â€¢ Set up SSL certificates for secure connections</p>
            <p>â€¢ Monitor your server performance and logs</p>
        </div>
        
        <p style="margin-top: 30px;">
            For documentation and support, visit <a href="http://nginx.org/" target="_blank">nginx.org</a>
        </p>
        
        <p style="font-size: 0.9em; color: #888; margin-top: 30px;">
            Powered by NGINXUI for ASUSWRT-Merlin
        </p>
    </div>
</body>
</html>
EOF

    log_info "Default index.html created in $document_root"
    return 0
}

# Export functions
export -f generate_nginx_config generate_basic_config generate_advanced_config
export -f generate_server_blocks generate_upstream_config generate_ssl_config
export -f backup_nginx_config restore_nginx_config create_default_index